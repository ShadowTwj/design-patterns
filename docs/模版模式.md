# 描述

**模板方法模式**是一种行为设计模式， 它在超类中定义了一个算法的框架， 允许子类在不修改结构的情况下重写算法的特定步骤。

这里的“算法”，我们可以理解为广义上的“业务逻辑”，并不特指数据结构和算法中的“算法”。这里的算法骨架就是“模板”，包含算法骨架的方法就是“模板方法”，这也是模板方法模式名字的由来。



# 结构

1. **抽象类** （Abstract­Class） 会声明作为算法步骤的方法， 以及依次调用它们的实际模板方法。 算法步骤可以被声明为 `抽象`类型， 也可以提供一些默认实现。
2. **具体类** （Concrete­Class） 可以重写所有步骤， 但不能重写模板方法自身。



# 实现

## 实现方式

1. 分析目标算法， 确定能否将其分解为多个步骤。 从所有子类的角度出发， 考虑哪些步骤能够通用， 哪些步骤各不相同。
2. 创建抽象基类并声明一个模板方法和代表算法步骤的一系列抽象方法。 在模板方法中根据算法结构依次调用相应步骤。 可用 `final`最终修饰模板方法以防止子类对其进行重写。
3. 虽然可将所有步骤全都设为抽象类型， 但默认实现可能会给部分步骤带来好处， 因为子类无需实现那些方法。
4. 可考虑在算法的关键步骤之间添加钩子。
5. 为每个算法变体新建一个具体子类， 它*必须*实现所有的抽象步骤， 也*可以*重写部分可选步骤。

## Demo

```java
/**
 * 抽象类，定义算法骨架，以及需要重写的方法步骤
 */
public abstract class AbstractClass {
    public final void templateMethod() {
        method1();

        method2();
    }

    protected abstract void method1();

    protected abstract void method2();
}

/**
 * 具体实现类，重写步骤方法
 */
public class ConcreteClass1 extends AbstractClass {
    @Override
    protected void method1() {
        // ...
    }

    @Override
    protected void method2() {
        // ...
    }
}

/**
 * 具体实现类，重写步骤方法
 */
public class ConcreteClass2 extends AbstractClass {
    @Override
    protected void method1() {
        // ...
    }

    @Override
    protected void method2() {
        // ...
    }
}
```



# 模版模式作用

模板模式主要是用来解决复用和扩展两个问题

## 复用

模板模式把一个算法中不变的流程抽象到父类的模板方法 `templateMethod()` 中，将可变的部分 `method1()`、`method2()` 留给子类 `ContreteClass1` 和 `ContreteClass2` 来实现。所有的子类可以复用父类中提供的模板方法的代码

如Java中的模版方法：

- java.io.InputStream、java.io.OutputStream、java.io.Reader 和 java.io.Writer 的所有非抽象方法
- java.util.AbstractList、java.util.AbstractSet 和 java.util.AbstractMap 的所有非抽象方法

## 扩展

这里所说的扩展，并不是指代码的扩展性，而是指框架的扩展性，有点类似控制反转

框架通过模板模式提供功能扩展点，让框架用户可以在不修改框架源码的情况下，基于扩展点定制化框架的功能

如 Junit TestCase、Java Servlet 等，都用到了模版模式扩展的作用



# 模板模式与Callback回调函数

从应用场景上来看，同步回调跟模板模式几乎一致。它们都是在一个大的算法骨架中，自由替换其中的某个步骤，起到代码复用和扩展的目的。而异步回调跟模板模式有较大差别，更像是观察者模式

从代码实现上来看，回调和模板模式完全不同。回调基于组合关系来实现，把一个对象传递给另一个对象，是一种对象之间的关系；模板模式基于继承关系来实现，子类重写父类的抽象方法，是一种类之间的关系

组合优于继承，在代码实现上，回调相对于模板模式会更加灵活，主要体现在下面几点：

- 像 Java 这种只支持单继承的语言，基于模板模式编写的子类，已经继承了一个父类，不再具有继承的能力
- 回调可以使用匿名类来创建回调对象，可以不用事先定义类；而模板模式针对不同的实现都要定义不同的子类
- 如果某个类中定义了多个模板方法，每个方法都有对应的抽象方法，那即便我们只用到其中的一个模板方法，子类也必须实现所有的抽象方法。而回调就更加灵活，我们只需要往用到的模板方法中注入回调对象即可



# 适用场景

1. 当你只希望客户端扩展某个特定算法步骤， 而不是整个算法或其结构时， 可使用模板方法模式。

   模板方法将整个算法转换为一系列独立的步骤， 以便子类能对其进行扩展， 同时还可让超类中所定义的结构保持完整。

2. 当多个类的算法除一些细微不同之外几乎完全一样时， 你可使用该模式。 但其后果就是， 只要算法发生变化， 你就可能需要修改所有的类。

   在将算法转换为模板方法时， 你可将相似的实现步骤提取到超类中以去除重复代码。 子类间各不同的代码可继续保留在子类中。



# 优缺点

1. 优点：
   - 你可仅允许客户端重写一个大型算法中的特定部分， 使得算法其他部分修改对其所造成的影响减小。
   - 你可将重复代码提取到一个超类中。
2. 缺点：
   - 部分客户端可能会受到算法框架的限制。
   - 通过子类抑制默认步骤实现可能会导致违反*里氏替换原则*。
   - 模板方法中的步骤越多， 其维护工作就可能会越困难。



# 与其他模式关系

- **工厂方法模式**是**模板方法模式**的一种特殊形式。 同时， 工厂方法可以作为一个大型模板方法中的一个步骤。
- **模板方法**基于继承机制： 它允许你通过扩展子类中的部分内容来改变部分算法。 **策略模式**基于组合机制： 你可以通过对相应行为提供不同的策略来改变对象的部分行为。 模板方法在类层次上运作， 因此它是静态的。 策略在对象层次上运作， 因此允许在运行时切换行为。