# 描述

**状态模式**是一种行为设计模式， 让你能在一个对象的内部状态变化时改变其行为， 使其看上去就像改变了自身所属的类一样。

状态模式一般用来实现状态机，先了解一下状态机，以及实现方式。



# 状态机

## 有限状态机

[有限状态机](https://zh.wikipedia.org/wiki/%E6%9C%89%E9%99%90%E7%8A%B6%E6%80%81%E6%9C%BA)，英文翻译是 Finite State Machine，缩写为 FSM，简称为状态机。状态机有 3 个组成部分：**状态（State）**、**事件（Event）**、**动作（Action）**。其中，事件也称为转移条件（Transition Condition）。事件触发状态的转移及动作的执行。不过，动作不是必须的，也可能只转移状态，不执行任何动作。

## 实现方式

1. 条件运算符实现

   最简单的方式是参照状态转移图，将每一个状态转移，直译成代码。由众多条件运算符 （` if` 或 `switch` ） 实现

   对于简单的状态机来说，这种实现方式是可以接受的。但是，对于复杂的状态机来说，这种实现方式极易漏写或者错写某个状态转移。除此之外，代码中充斥着大量的 `if-else` 或者 `switch-case` 分支判断逻辑，可读性和可维护性都很差。

2. 查表法实现

   对于复杂的状态机，可以采用查表法

   状态机二维数组来表示，第一维表示当前状态，第二维表示事件，值表示当前状态经过事件之后，转移到的新状态及其执行的动作。

   适合状态很多、状态转移比较复杂、动作简单的状态机。

3. 状态模式实现

   查表法有一定的局限性，如果执行的动作是复杂的业务逻辑，则查表法就无法简单来实现了，这种情况则需要采用状态模式。

   适合状态并不多、状态转移也比较简单，但事件触发执行的动作包含的业务逻辑可能比较复杂的状态机，具体实现如下。



# 结构

1. **上下文** （Context） 保存了对于一个具体状态对象的引用， 并会将所有与该状态相关的工作委派给它。 上下文通过状态接口与状态对象交互， 且会提供一个设置器用于传递新的状态对象。

2. **状态** （State） 接口会声明特定于状态的方法。 这些方法应能被其他所有具体状态所理解， 因为你不希望某些状态所拥有的方法永远不会被调用。

3. **具体状态** （Concrete States） 会自行实现特定于状态的方法。 为了避免多个状态中包含相似代码， 你可以提供一个封装有部分通用行为的中间抽象类。

   状态对象可存储对于上下文对象的反向引用。 状态可以通过该引用从上下文处获取所需信息， 并且能触发状态转移。

4. 上下文和具体状态都可以设置上下文的下个状态， 并可通过替换连接到上下文的状态对象来完成实际的状态转换。

> 可能看上去与策略模式相似， 但有一个关键性的不同——在状态模式中， 特定状态知道其他所有状态的存在， 且能触发从一个状态到另一个状态的转换； 策略则几乎完全不知道其他策略的存在。



# 实现

## 实现方式

1. 确定哪些类是上下文。 它可能是包含依赖于状态的代码的已有类； 如果特定于状态的代码分散在多个类中， 那么它可能是一个新的类。

2. 声明状态接口。 虽然你可能会需要完全复制上下文中声明的所有方法， 但最好是仅把关注点放在那些可能包含特定于状态的行为的方法上。

3. 为每个实际状态创建一个继承于状态接口的类。 然后检查上下文中的方法并将与特定状态相关的所有代码抽取到新建的类中。

   在将代码移动到状态类的过程中， 你可能会发现它依赖于上下文中的一些私有成员。 你可以采用以下几种变通方式：

   - 将这些成员变量或方法设为公有。
   - 将需要抽取的上下文行为更改为上下文中的公有方法， 然后在状态类中调用。 这种方式简陋却便捷， 你可以稍后再对其进行修补。
   - 将状态类嵌套在上下文类中。 这种方式需要你所使用的编程语言支持嵌套类。

4. 在上下文类中添加一个状态接口类型的引用成员变量， 以及一个用于修改该成员变量值的公有设置器。

5. 再次检查上下文中的方法， 将空的条件语句替换为相应的状态对象方法。

6. 为切换上下文状态， 你需要创建某个状态类实例并将其传递给上下文。 你可以在上下文、 各种状态或客户端中完成这项工作。 无论在何处完成这项工作， 该类都将依赖于其所实例化的具体类。



## Demo

- 声明状态接口

  ```java
  /**
   * 通用状态接口，声明特定于状态的方法。
   */
  public interface State {
  
      /**
       * 事件对应动作，并触发状态转移
       */
      void eventAction();
  }
  ```

- 状态上下文

  ```java
  /**
   * 状态上下文
   * <p>
   * 保存了对于一个具体状态对象的引用， 并会将所有与该状态相关的工作委派给它
   * 上下文通过状态接口与状态对象交互， 且会提供一个设置器用于传递新的状态对象
   */
  public class StateContext implements State {
      /**
       * 具体状态对象引用
       */
      private State state;
  
      public StateContext() {
          // 初始化状态
          this.state = new StateConcreteA(this);
      }
  
      @Override
      public void eventAction() {
          state.eventAction();
      }
  
      public State getState() {
          return state;
      }
  
      public void setState(State state) {
          this.state = state;
      }
  }
  ```

- 具体状态实现类

  ```java
  /**
   * 具体状态
   */
  public class StateConcreteA implements State {
      /**
       * 状态上下文，可以通过上下文引用获取所需信息
       * 并且通过上下文触发状态转移
       */
      private final StateContext context;
  
      public StateConcreteA(StateContext context) {
          this.context = context;
      }
  
      @Override
      public void eventAction() {
          // action...
  
          // 状态转移
          context.setState(new StateConcreteB(context));
      }
  }
  
  /**
   * 具体状态
   */
  public class StateConcreteB implements State {
      /**
       * 状态上下文，可以通过上下文引用获取所需信息
       * 并且通过上下文触发状态转移
       */
      private final StateContext context;
  
      public StateConcreteB(StateContext context) {
          this.context = context;
      }
  
      @Override
      public void eventAction() {
          // action
  
          // 状态转移
          context.setState(new StateConcreteA(context));
      }
  }
  ```



# 适用场景

1. 如果对象需要根据自身当前状态进行不同行为， 同时状态的数量非常多且与状态相关的代码会频繁变更的话， 可使用状态模式。

   模式建议你将所有特定于状态的代码抽取到一组独立的类中。 这样一来， 你可以在独立于其他状态的情况下添加新状态或修改已有状态， 从而减少维护成本。

2. 如果某个类需要根据成员变量的当前值改变自身行为， 从而需要使用大量的条件语句时， 可使用该模式。

   状态模式会将这些条件语句的分支抽取到相应状态类的方法中。 同时， 你还可以清除主要类中与特定状态相关的临时成员变量和帮手方法代码。

3. 当相似状态和基于条件的状态机转换中存在许多重复代码时， 可使用状态模式。

   状态模式让你能够生成状态类层次结构， 通过将公用代码抽取到抽象基类中来减少重复。



# 优缺点

## 优点

- *单一职责原则*。 将与特定状态相关的代码放在单独的类中。
- *开闭原则*。 无需修改已有状态类和上下文就能引入新状态。
- 通过消除臃肿的状态机条件语句简化上下文代码。

## 缺点

- 如果状态机只有很少的几个状态， 或者很少发生改变， 那么应用该模式可能会显得小题大作。



# 与其他模式关系

- `桥接模式`、 `状态模式`和`策略模式` （在某种程度上包括`适配器模式`） 模式的接口非常相似。 实际上， 它们都基于`组合模式`——即将工作委派给其他对象， 不过也各自解决了不同的问题。 模式并不只是以特定方式组织代码的配方， 你还可以使用它们来和其他开发者讨论模式所解决的问题。
- `状态`可被视为`策略`的扩展。 两者都基于组合机制： 它们都通过将部分工作委派给 “帮手” 对象来改变其在不同情景下的行为。 *策略*使得这些对象相互之间完全独立， 它们不知道其他对象的存在。 但`状态模式`没有限制具体状态之间的依赖， 且允许它们自行改变在不同情景下的状态。